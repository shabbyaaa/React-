# 为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？

## React源码中的解释

React不能通过双端对比Diff算法优化是因为目前Fiber上没有设置反向链表，而且
想知道就目前这种方案能持续多久，如果目前这种模式不理想的话，那么也可以增
加双端对比算法

```js
// 指向父级Fiber节点
this.return = null;
// 指向子Fiber节点
this.child = null;
// 指向右边第一个兄弟Fiber节点
this.sibling = null;
```

`Fiber`链表结构特点：任何一个位置的`Fiber`节点，都可以非常容易知道它的父
`Fiber`,第一个子元素的`Fiber`，和兄弟`Fiber`。却不容易知道它前一个`Fiber`节点是
谁。正是因为这种结构即便协调的过程被中断了，再恢复协调的时候，依然知道当
前父节点和子节点等信息。

`Fiber`链表生成

经过`JSX`编译后，创建`fiberRoot`的fiber节点，然后从这个根fiber开始协调，生
成一颗fiber树。这棵树被称为 `workInProgress Fiber` 树，即正在工作的fiber
树

```js
// 协调子节点的函数接受两个参数，父Fiber 子元素的虚拟DOM数据
export function reconcileChildren(returnFiber, children) {
  // 如果是字符串或者数字则不创建 fiber
  if (isStringOrNumber(children)) {
    return
  }
  const newChildren = isArray(children) ? children : [children]
  // 上一轮的fiber节点
  let previousNewFiber = null
  // 初次渲染（false）还是更新（true）
  let shouldTrackSideEffects = !!returnFiber.alternate
  // 老fiber节点
  let oldFiber = returnFiber.alternate && returnFiber.alternate.child
  // 上一次协调返回的位置
  let lastPlacedIndex = 0
  // 记录每个fiber节点的位置
  let newIdx = 0 
  // 如果不存在老fiber则是初始化过程，进行fiber链表的创建
  if (!oldFiber) {
    for (; newIdx < newChildren.length; newIdx++) {
      const newChild = newChild[newIdx]

      if (newChild === null) {
        continue
      }
      // 创建新fiber的时候记录关键的父fiber信息
      const newFiber = createFiber(newChild, returnFiber)
      //  记录当前每一个fiber的位置
      lastPlacedIndex = placeChild(
        newFiber, 
        lastPlacedIndex, 
        newIdx, 
        shouldTrackSideEffects
      )
      // 当上一轮fiber节点为null时，这一轮的fiber就是头节点
      if (previousNewFiber === null) {
        returnFiber.child = newFiber 
      } else {
        // 如果不是第一个节点 则为兄弟节点
        previousNewFiber.sibling = newFiber
      }
      // 记录上一轮的fiber，即是这一轮fiber 便是下一轮的上一轮fiber
      previousNewFiber = newFiber
    }
    return
  }
}
```

构建完的 `workInProgress Fiber`树会在 `commit` 阶段渲染到页面

在组件状态数据发生变更的时候，会根据最新的状态数据先甚至新的虚拟DOM，再去构建一颗新的`workInProgress Fiber`树，而在重新协调构建新的Fiber树的过程也就是React Diff发生的地方

## React的Diff算法

深度优先

重点是在更新自己的同时需要去协调子节点，即进行Diff的地方

进入协调的时候它自己就是父Fiber，它的子节点在协调之前，是刚刚通过更新的状
态数据生成的最新的虚拟DOM数据，是个数组结构的元素数据。

那么要进行更新，就肯定是以最新的节点数据为准了，又因为最新的节点数据是一
个数组，所以可以进行循环对比每一个节点，很明显这个循环是从左向右进行查找
对比的

### 第一轮常见情况的对比

那么第一个节点的老Fiber怎么拿到呢？可以通过父fiber的child属性拿到，这样
第一个节点的老fiber就拿到了，那么第二节点的老fiber，就可以通过第一个节点
老fiber节点sibling属性拿到。

怎么对比呢？
在循环的新节点虚拟DOM数据的时候，拿到新节点虚拟DOM信息，然后去和老fiber
节点进行对比，如果两个节点相同则创建一个新的fiber节点并复用一些老fiber节
点的信息，比如真实DOM，并给这个新的fiber节点打上一个Update标记，代表这个
节点需要更新即可。

接着去更新协调位置信息

再循环的最后进行fiber链表的处理：
如果是头结点，则把新fiber设置为父fiber的child属性；如果不是头结点，则把
新fiber设置为上一轮循环创建的fiber节点sibling属性的值；更新上一轮fiber
变量的值，就是把这一轮的fiber设置成下一轮的fiber；更新对比的老fiber的
值。

如果新节点都能找到能够复用的节点，则判断是否还存在老节点，有则删除。

### 第二轮不常见的情况的对比

如果经过第一轮对比，新节点还存在未对比的，则继续循环查找。

现将剩下未对比的老fiber节点全部处理成一个老fiber的key或者老fiber的index
为key，fiber节点为value的Map中，这样就可以以O(1)复杂度，通过新fiber的
key去Map对象中查找匹配的fiber，找到了，则删除Map对象中的老fiber数据，然
后复用匹配到的fiber数据。

接下来，不管有没有匹配到都进行位置协调，记录最新的位置信息，新增的fiber因
为没有存在老fiber而会被打伤Placement的标记，在将来提交的阶段将会被进行新
增操作。这个过程跟第一轮最后的处理是一样的。

在循环的最后进行fiber链表的处理：
如果是头结点，则把新fiber设置为父fiber的child属性的值；如果不是头结点，
则把新fiber设置为上一轮循环的创建的fiber节点的sibling属性的值；更新上一
轮fiber变量的值，就是把这一轮得fiber设置成下一轮的fiber；更新对比的老
fiber的值。

### 重点如何协调更新位置信息

如果初始渲染，那么协调位置就只是记录当前元素下表的位置到fiber节点上，如果
是更新阶段，就先判断有没有老fiber节点，如果没有老fiber节点，则说明该节点
需要创建，就给当前新的fiber节点打伤一个Placement的标记，如果有老fiber节
点，则判断老fiber节点的位置是否比上一次协调的返回的位置小，如果是，这说明

该节点需要移动，给新fiber节点打伤一个Placement标记，并继续返回上一次协调返回的位置；如果老fiber节点的位置大于或者等于上一次协调返回的位置，则说明
该节点不需要进行位置移动炒作，就返回老fiber的位置即可。

这里需要说明的一点，为什么移动和新增节点都是Placement的标记呢？

因为我们是在协调一个子节点列表，所以无论是新增还是移动都是属于位置需要发
生变化的，所以新增和移动都是同一种操作情况。

### 总结

React Diff算法分为以下几个步骤

1. 第一轮，从左向右新老节点进行对比查找找到能复用的旧节点，如果新节点对比
  不成功，则停止这一轮的对比，并记录停止的位置
2. 如果第一轮对比，能把所有新节点都对比完毕，则删除旧节点还没进行对比的节点
3. 如果第一轮的对比，没能将所有新节点都对比完毕，则继续从第一轮对比停止的
  位置继续开始循环新节点，拿每一个新节点去老节点里面进行查找，有匹配成功的则复用，没匹配成功的则在协调位置的时候打上Placement标记
4. 在所有新节点对比完毕之后，检查还有没有没进行复用的来节点，如果有，则全部删除。


匹配到的老fiber如果和新fiber相同或者在新fiber位置的右边，则不需要进行移动标记。


## Vue3 Diff算法

### 第一轮 常见情况的对比

首先从左往右进行对比，如果是相同的就进行更新对比，如果不相同则停止对比，
并记录停止的下标。再从右往左进行对比，如果是相同的就进行更新对比，如果不
相同也停止对比，记录停止的下表。通过这样左右进行对比，最后就可以把真正复
杂部分进行范围锁定了。左右对比完之后，如果新节点已经对比完了，老节点列表
还存在节点未对比，则删除老节点列表上的未对比的节点，如果老节点已经对比完
了，新节点列表还存在未对比的节点则进行创建

### 第二轮 复杂情况的对比

如果新节点未对比完，老节点也未对比完，则进行最后最复杂的处理

先把剩下的新节点处理成节点的key为key，节点下表为value的Map；接着初始化一
个长度为剩下未对比的新节点的长度的数组 newIndexToOldIndexMap，初始化每
个数组的下标默认为0。在循环剩下的旧节点，通过旧节点的key去刚刚创建的Map
中查找，看看旧节点有没有在新节点中，如果旧节点没有key则需要通过循环剩下的
新节点进行查找。如果旧节点在新节点中没找到，这说明该旧节点需要进行删除。
如果找到了，则把找到的新节点的下标对应存储到上述的数组 
newIndexToOldIndexMap 中，然后更新对比匹配到的新老节点。

把所有旧节点对比完成后，就会得到一个刚刚收集的新节点的下标数组，然后对这
个新节点的下标数组进行最长递增子序列查找得到一个最长递增子序列的下标数
组。然后在进行循环左右对比完之后剩下新节点的下标，然后判断循环的下标是否
被上述的数组 newIndexToOldIndexMap 进行收集了，如果没被收集这说明这个新
节点需要进行创建，如果已经被收集了则判断该循环的下标是否在上面计算得到的
最长递增子序列中，如果不在则需要对该循环节点进行移动操作

## Vue2的diff

以新的虚拟DOM为准进行与老虚拟DOM的对比，继而进行各种情况的处理。大概可以
分为四种情况，更新节点、新增节点、删除节点、移动节点位置。对比新来两个虚
拟DOM，就是通过循环，每循环到一个新节点，就取老节点列表里面找到和当前新节
点相同的旧节点。如果在旧节点列表中找不同，说明当前节点是需要新增的节点，
我们就需要进行创建节点并插入试图的炒作；如果找到了，就做更新操作；如果找
到的旧节点与新节点的位置不同，则需要移动节点等。

### 第一轮 简单情况的对比

其中为了快速查到节点，Vue2的diff算法设置了4中优化策略
1. 老数组的开始与新数组的开始
2. 老数组的结尾与新数组的结尾
3. 老数组的开始和新数组的结尾
4. 老数组的结尾和新数组的开始

通过这四种快速查找方式，就不需要循环来查找了，只有当这四种方式都查不到的
时候，再进行循环查找

### 第二轮 不常见情况的对比

最后循环结束后需要对未处理的节点进行处理

如果是老节点列表先循环完毕，这个时候如果新节点列表还有剩余的节点，这说明
这些节点都是需要新增的节点，直接把这些节点创建并插入到DOM中就行了

如果新节点列表县循环完毕，这个时候如果老节点列表还有剩余节点，则说明这些
节点都是要被废弃的节点，是应该被删除的直接批量删除即可

## 相同点

只有使用了虚拟DOM这些框架，在进行更新Diff对比的时候，都是优先处理简单的
场景，再处理复杂的场景

React是先处理左边部分，左边部分处理不了，在进行复杂部分的处理；Vue3则先
处理收尾部分，然后在处理中间复杂部分。

在处理老节点部分，都需要先把节点处理key - value的Map数据结构，方便在往后
的对比中可以快速通过节点的key取到对应的节点。同样在对比两个新老节点是否相
同时，key是否相同也是非常重要的判断标准。所以无论是React还是vue，在写动
态列表的时候，都需要设置一个唯一值key，这样在diff算法处理的时候性能才能
最大化。

## 不同点

对静态节点的处理不一样

由于Vue是通过template模板进行编译的，所以在编译的时候可以很好对静态节点
进行分析然后打补丁标记，然后在diff的时候，Vue2是判断如果是静态节点则跳过
循环对比，而Vue3则是把整个静态节点进行提升处理，diff的时候是不进入循环
的，所以Vue3比Vue2的diff性能更高效。而React因为是通过JSX进行编译的，是
无法通过静态节点分析的，所以React在对静态节点处理这一块要逊色

Vue的对比和更新时同步进行的，跟React15是相同的，就是在对比的过程中，如果
发现了那些节点需要移动或者更新删除，是立即执行的，也就是React中常讲的不可
中断的更新，如果对比量过大的话，就会造成卡顿，所以React16就更改为了对比
和更新是异步进行的，所以React16以后的diff是可以中断的，diff和任务调度都
是在内存中进行的，所以即便中断了，用户也不会知道

Vue使用了双端对比算法，而React的fiber由于是单向链表的结构，所以在React
不设置由右向左的链表之前，都无法实现双端对比。那么双端对比目前React的
diff要好吗

eg：现在有以下两组新老节点

老：A, B, C, D
新：D, A, B, C

新老节点唯一不同 D节点在新的节点中跑到开头去了

在这种情况下，React是从左向右进行对比的，在上述这种情况，React需要把A, 
B, C三个节点分别移动到D节点后面

Vue2在进行老节点的结尾与新节点的开始对比的时候，就发现这两个节点是相同
的，所以直接把老节点结尾的D移动到新节点的开头就行了，剩下的只进行来节点的
开始和新节点的开始进行对比，就可以发现它的位置并没有发生改变，不需要进行
移动
Vue3是没有Vue2的新老首尾节点进行比较的，只是从两组节点的开头和结尾进行比
较，然后往中间靠拢，那么Vue3在进行新节点的开始和结尾对比的时候，都没有对
比成功，那么接下来就进行中间部分的对比，先把老节点处理成key-value的Map数
据结构，然后又实用最长递增子序列算法找出其中的稳定部分，也就是A, B, C，
然后在对新节点进行循环对比，然后就会发现新节点的A, B, C都在稳定序列部
分，不需要进行移动，然后就只对D，进行移动即可

在Vue2和Vue3中都只需要移动一个节点就可以完成diff算法对比，而React在这种
极端例子中则没办法进行很好的优化，需要进行多次节点移动操作

## 为什么Vue中不需要使用fiber（为什么Vue不需要时间分片）

第一，首先时间分片是为了解决CPU进行大量计算的问题，因为React本身架构的问
题，在默认的情况下更新会进行过多的计算，就算使用React提供的性能优化API，
进行设置，也会因为开发者本身的为题，依然可能存在过多计算的问题

第二，而Vue通过响应式依赖跟踪，在默认的情况下可以做到只进行组件级别的更新
计算，而默认下React是做不到的。Vue是通过template进行编译的，可以在编译的
时候进行非常好的性能优化，比如对静态节点进行静态节点提升的优化处理，而通
过JSX进行编译的React是做不到的

第三，React为了解决更新的时候进行过多计算的问题引入了时间分片，但同时又带
来了额外的计算开销，就是任务协调的计算，虽然React使用了最小堆等算法进行优
化，但相对Vue还是多了额外的性能开销，因为Vue没有时间分片，所以没有这方面
的性能担忧

第四，根据研究表明，人类的肉眼对100毫秒以内的时间并不敏感，所以时间分片只
对于处理超过100毫秒以上的计算才有很好的收益，而Vue的更新计算是很少出现
100毫秒以上的计算的，所以Vue引入时间分片的收益不划算
